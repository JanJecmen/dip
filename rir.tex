\chapter{About RIR\label{rir}}

RIR is an alternative compiler for the R language.\footnote{Homepage: \url{https://github.com/reactorlabs/rir}} It comes with its own internal representation, an interpreter for its bytecode and an abstract interpretation framework which provides a way to easily implement static analyses on top of the RIR bytecode.

RIR acts as a drop-in replacement for the GNU R bytecode compiler. It requires a patched version of GNU R that makes some slight adjustments that allow the standard GNU R expression evaluator function to interface with the RIR bytecode compiler and interpreter. RIR is written in C and C++ and is compiled as a shared library that can be dynamically loaded by R.

Listing \ref{lst:rir} shows how to manually load RIR (although there is a script \emph{tools/R} that does this autmatically and turns on JIT, too).

\begin{listing}[htbp]
  \caption{\label{lst:rir}Loading RIR at runtime}
  \begin{rcode}
> dyn.load("~/rir/build/librir.so")  # path to the shared object
> source("~/rir/rir/R/rir.R")  # load the API for RIR compiler
> # RIR is now ready:
> f <- rir.compile(function() {})
> f
function() {}
<bytecode: 0x34b4510>
> rir.disassemble(f)
0x2f80538
   guard_fun_  { == 0x2077cd8
   push_  23 # NULL
   ret_ 
  \end{rcode}
\end{listing}

The architecture is very similar to GNU R. The compiler generates bytecode for a stack oriented virtual machine, which is later executed by a bytecode interpreter. However, RIR is designed to be multi pass, and provides a framework for adding new analyses, transformations and optimizations.

\todo[write about rir bytecode]

\todo[how is rir bc different]

As opposed to the assumptions used by the GNU R compielr (see \ref{assumptions}), RIR uses guards to check at runtime whether the assumption holds or not (i.e. whether the inlined function is still the same as it was at compile time).

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 

\section{Why is RIR slow}

RIR is at present slower than GNU R. This is caused by several factors.

First, RIR falls back to the AST interpreter more often than GNU R.

Second, RIR allocates more memory than GNU R. For example, GNU R does not create promises out of constant arguments passed to a closure. RIR, on the other hand, creates promises from each argument.

Moreover, the GNU R bytecode interpreter is very optimized and efficient, as opposed to RIR.

% \todo[history: research project, northeastern? first appearence?]
