\chapter{About RIR\label{rir}}

RIR is an alternative compiler for the R language.\footnote{Homepage: \url{https://github.com/reactorlabs/rir}} It comes with its own internal representation, an interpreter for its bytecode and an abstract interpretation framework which provides a way to easily implement static analyses on top of the RIR bytecode.

RIR acts as a drop-in replacement for the GNU R bytecode compiler. It requires a patched version of GNU R that makes some slight adjustments that allow the standard GNU R expression evaluator function to interface with the RIR bytecode compiler and interpreter. RIR is written in C (the interpreter) and C++ (the compiler and analysis framework) and is compiled as a shared library that can be dynamically loaded by R.

Listing \ref{lst:rir} shows how to manually load RIR (although a script \emph{tools/R} is provided that does this autmatically and turns on JIT, too).

\begin{listing}[htbp]
  \caption{\label{lst:rir}Loading RIR at runtime}
  \begin{rcode}
> dyn.load("~/rir/build/librir.so")  # path to the shared object
> source("~/rir/rir/R/rir.R")  # load the API for RIR compiler
> # RIR is now ready:
> f <- rir.compile(function() {})
> f
function() {}
<bytecode: 0x34b4510>
> rir.disassemble(f)
0x2f80538
   guard_fun_  { == 0x2077cd8
   push_  23 # NULL
   ret_ 
  \end{rcode}
\end{listing}

The architecture is very similar to GNU R. The compiler generates bytecode for a stack oriented virtual machine, which is later executed by a bytecode interpreter. However, RIR is designed to be multi pass, and provides a framework for adding new analyses, transformations and optimizations.

The RIR bytecode was designed with analyses in mind. This lead to some design decisions that are quite different from GNU R.

Firstly, the bytecodes have statically defined how they behave, i.e. if they have observable side-effects and how many elements they pop off and how many they push on the stack. This information allows the analyses to better reason about the code.

Secondly, RIR instructions aim to be predictable and self-contained.

For instance, when compiling a call, GNU R emits as many instructions as there are call arguments. On top of that, they are of multiple kinds: \rinline/PUSHCONSTARG.OP/ and its variants for constants and \rinline/MAKEPROM.OP/ for non-constants.

RIR behaves much more regularly in such a case. It compiles all arguments as promises (or rather, just the code objects for the expressions, since the promise environments are added only at runtime) and emits a single \cinline/call_/ instruction. The arguments are passed indirectly via an index of a call site structure for the particular call.

Later at runtime, the GNU R instructions build a linked list of arguments on the stack, however the behavior depends on the type of the callee. The \rinline/MAKEPROM.OP/ instruction decides at runtime whether it will allocate a promise (for closures), evaluate the code right away (for builtins) or do nothing at all (for specials).

RIR prepares the arguments at runtime and either evaluates them all eagerly or allocates them all as promises.

Another example is a \rinline/for/ loop. GNU R uses three instructions that handle everyhing: one for initializing the loop variable, one for advancing it along the loop sequence, and one to clean up.

RIR on the other hand emits insructions for every operation, such as incrementing the index variable, checking its bounds, jumping out of the loop conditionally, extracting the appropriate element of the loop sequence, storing it in the loop variable etc.

In general, where GNU R uses complex instructions that have to cover a lot of work, RIR aims to achieve the same results by using lighter and more specialized instructions (reminiscent of the reduced instruction set ideals).

Furthermore, as opposed to the assumptions used by the GNU R compiler (see \ref{assumptions}), RIR uses guard instructions that check at runtime whether the assumption holds or not (i.e. whether the inlined function is still the same as it was at compile time).

RIR is at present slower than GNU R. This is caused by several factors. First, RIR falls back to the AST interpreter more often than GNU R. Second, RIR allocates more memory than GNU R. For example, GNU R does not create promises out of constant arguments passed to a closure. RIR, on the other hand, creates promises from each argument. Moreover, the GNU R bytecode interpreter loop is very optimized and efficient, as opposed to RIR's.

Some examples of RIR instructions are listed in talbe \ref{tab:rir-instr}.

\begin{longtable}[c]{@{}ll@{}}
\caption{Description of some RIR bytecodes\label{tab:rir-instr}} \tabularnewline
\toprule
Instruction & Description \tabularnewline
\midrule
\endfirsthead
\toprule
Instruction & Description \tabularnewline
\midrule
\endhead
\cinline/push_/ & Push on top of stack \tabularnewline
\cinline/pop_/ & Pop off the stack \tabularnewline
\cinline/ldvar_/ & Look up binding \tabularnewline
\cinline/stvar_/ & Update binding \tabularnewline
\cinline/close_/ & Create closure \tabularnewline
\cinline/ret_/ & Standard return \tabularnewline
\cinline/return_/ & Non-local return \tabularnewline
\cinline/asbool_/ & Convert top of stack to \rinline/TRUE/ or \rinline/FALSE/ \tabularnewline
\cinline/brtrue_/ & Jump based on top of stack \tabularnewline
\cinline/brobj_/ & Jump if top of stack is object \tabularnewline
\cinline/br_/ & Jump unconditionally \tabularnewline
\cinline/dup_/ & Duplicate top of stack \tabularnewline
\cinline/dup2_/ & Duplicate two top elements \tabularnewline
\cinline/add_/ & Arithmetic addition \tabularnewline
\cinline/guard_fun_/ & Check function is same as at compile time \tabularnewline
\cinline/extract1_/ & Get an element of vector \tabularnewline
\cinline/inc_/ & Increment integer on top of stack\tabularnewline
\bottomrule
\end{longtable}
